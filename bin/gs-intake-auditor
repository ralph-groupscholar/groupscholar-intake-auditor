#!/usr/bin/env ruby

require "csv"
require "json"
require "optparse"
require "time"

options = {
  json_path: nil,
  sample_limit: 10,
  required_headers: nil,
  recent_days: 7,
  stale_days: 180,
  status_allowlist: nil,
  stage_allowlist: nil
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: gs-intake-auditor <csv_path> [options]"

  opts.on("--json PATH", "Write full report JSON to PATH") do |path|
    options[:json_path] = path
  end

  opts.on("--sample N", Integer, "Max issue sample rows to show (default: 10)") do |n|
    options[:sample_limit] = [n, 0].max
  end

  opts.on("--require HEADERS", "Comma-separated required headers (override defaults)") do |value|
    headers = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:required_headers] = headers unless headers.empty?
  end

  opts.on("--recent-days N", Integer, "Days to count as recent submissions (default: 7)") do |n|
    options[:recent_days] = [n, 0].max
  end

  opts.on("--stale-days N", Integer, "Days to flag as stale submissions (default: 180)") do |n|
    options[:stale_days] = [n, 0].max
  end

  opts.on("--status-allowlist VALUES", "Comma-separated allowed statuses (flags unknown values)") do |value|
    statuses = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:status_allowlist] = statuses unless statuses.empty?
  end

  opts.on("--stage-allowlist VALUES", "Comma-separated allowed stages (flags unknown values)") do |value|
    stages = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:stage_allowlist] = stages unless stages.empty?
  end

  opts.on("-h", "--help", "Show help") do
    puts opts
    exit 0
  end
end

parser.parse!

csv_path = ARGV.shift
if csv_path.nil? || csv_path.strip.empty?
  warn "Missing CSV path."
  puts parser
  exit 1
end

unless File.exist?(csv_path)
  warn "CSV not found: #{csv_path}"
  exit 1
end

default_required_headers = %w[applicant_id name email program submitted_at status stage score]
required_headers = options[:required_headers] || default_required_headers

rows = []
headers = nil

begin
  CSV.foreach(csv_path, headers: true) do |row|
    headers ||= row.headers
    rows << row
  end
rescue CSV::MalformedCSVError => e
  warn "CSV parse error: #{e.message}"
  exit 1
end

headers ||= []
missing_headers = required_headers - headers
required_headers_in_file = required_headers & headers

missing_values = Hash.new(0)
status_counts = Hash.new(0)
stage_counts = Hash.new(0)
program_counts = Hash.new(0)
program_required_stats = {}
email_counts = Hash.new(0)
applicant_id_counts = Hash.new(0)
unknown_status_values = Hash.new(0)
unknown_stage_values = Hash.new(0)
score_values = []
submission_times = []
submission_weekday_counts = Hash.new(0)
submission_hour_counts = Hash.new(0)
issue_rows = []
blank_status = 0
blank_stage = 0
blank_program = 0
invalid_email_count = 0
invalid_score_count = 0
score_out_of_range_count = 0
invalid_submitted_at_count = 0
future_submissions_count = 0
stale_submissions_count = 0
unknown_status_count = 0
unknown_stage_count = 0
complete_required_rows = 0

email_regex = /\A[^@\s]+@[^@\s]+\.[^@\s]+\z/
now = Time.now
recent_cutoff = now - (options[:recent_days] * 24 * 60 * 60)
stale_cutoff = now - (options[:stale_days] * 24 * 60 * 60)
recent_submissions = 0

rows.each_with_index do |row, index|
  row_number = index + 2
  issues = []
  missing_required = false
  missing_fields = []

  required_headers_in_file.each do |header|
    value = row[header]
    if value.nil? || value.strip.empty?
      missing_values[header] += 1
      issues << "missing_#{header}"
      missing_required = true
      missing_fields << header
    end
  end
  complete_required_rows += 1 unless missing_required

  email = row["email"].to_s.strip
  if !email.empty?
    email_counts[email.downcase] += 1
    unless email_regex.match?(email)
      invalid_email_count += 1
      issues << "invalid_email"
    end
  end

  applicant_id = row["applicant_id"].to_s.strip
  applicant_id_counts[applicant_id] += 1 unless applicant_id.empty?

  score_raw = row["score"].to_s.strip
  unless score_raw.empty?
    begin
      score = Float(score_raw)
      score_values << score
      unless score.between?(0, 100)
        score_out_of_range_count += 1
        issues << "score_out_of_range"
      end
    rescue ArgumentError
      invalid_score_count += 1
      issues << "invalid_score"
    end
  end

  submitted_at_raw = row["submitted_at"].to_s.strip
  unless submitted_at_raw.empty?
    begin
      submitted_at = Time.parse(submitted_at_raw)
      submission_times << submitted_at
      submission_weekday_counts[submitted_at.strftime("%A")] += 1
      submission_hour_counts[submitted_at.strftime("%H")] += 1
      recent_submissions += 1 if submitted_at >= recent_cutoff
      if submitted_at > now
        future_submissions_count += 1
        issues << "submitted_at_in_future"
      end
      if submitted_at < stale_cutoff
        stale_submissions_count += 1
        issues << "submitted_at_stale"
      end
    rescue ArgumentError
      invalid_submitted_at_count += 1
      issues << "invalid_submitted_at"
    end
  end

  status = row["status"].to_s.strip
  if status.empty?
    blank_status += 1
  else
    status_counts[status] += 1
    if options[:status_allowlist] && !options[:status_allowlist].include?(status)
      unknown_status_count += 1
      unknown_status_values[status] += 1
      issues << "unknown_status"
    end
  end

  stage = row["stage"].to_s.strip
  if stage.empty?
    blank_stage += 1
  else
    stage_counts[stage] += 1
    if options[:stage_allowlist] && !options[:stage_allowlist].include?(stage)
      unknown_stage_count += 1
      unknown_stage_values[stage] += 1
      issues << "unknown_stage"
    end
  end

  program = row["program"].to_s.strip
  if program.empty?
    blank_program += 1
  else
    program_counts[program] += 1
    program_stats = program_required_stats[program] ||= {
      total_rows: 0,
      missing_required_rows: 0,
      missing_required_fields: Hash.new(0)
    }
    program_stats[:total_rows] += 1
    if missing_required
      program_stats[:missing_required_rows] += 1
      missing_fields.each { |field| program_stats[:missing_required_fields][field] += 1 }
    end
  end

  issue_rows << {
    row: row_number,
    applicant_id: row["applicant_id"],
    issues: issues
  } unless issues.empty?
end

duplicate_emails = email_counts.select { |_email, count| count > 1 }
duplicate_applicant_ids = applicant_id_counts.select { |_id, count| count > 1 }

score_stats = if score_values.empty?
  nil
else
  total = score_values.sum
  {
    min: score_values.min,
    max: score_values.max,
    avg: (total / score_values.length.to_f).round(2)
  }
end

submission_window = if submission_times.empty?
  nil
else
  {
    earliest: submission_times.min.iso8601,
    latest: submission_times.max.iso8601
  }
end

complete_required_rows_pct = rows.empty? ? 0.0 : (complete_required_rows * 100.0 / rows.length).round(1)
weekday_order = %w[Monday Tuesday Wednesday Thursday Friday Saturday Sunday]
submission_weekday_distribution = weekday_order.each_with_object({}) do |day, acc|
  count = submission_weekday_counts[day]
  acc[day] = count if count.positive?
end
submission_hour_distribution = submission_hour_counts.sort_by { |k, _| k }.to_h

field_completeness = {}
required_headers_in_file.each do |header|
  missing_count = missing_values[header] || 0
  present_count = rows.length - missing_count
  coverage = rows.empty? ? 0.0 : (present_count * 100.0 / rows.length).round(1)
  field_completeness[header] = {
    missing: missing_count,
    present: present_count,
    coverage_pct: coverage
  }
end

program_required_completeness = program_required_stats.map do |program, stats|
  total = stats[:total_rows]
  missing = stats[:missing_required_rows]
  coverage_pct = total.zero? ? 0.0 : ((total - missing) * 100.0 / total).round(1)
  top_missing_fields = stats[:missing_required_fields].sort_by { |_, v| -v }.to_h
  [
    program,
    {
      total_rows: total,
      missing_required_rows: missing,
      missing_required_pct: total.zero? ? 0.0 : (missing * 100.0 / total).round(1),
      coverage_pct: coverage_pct,
      missing_required_fields: top_missing_fields
    }
  ]
end.to_h

report = {
  file: File.expand_path(csv_path),
  generated_at: now.iso8601,
  total_rows: rows.length,
  headers: headers,
  missing_headers: missing_headers,
  missing_values: missing_values.sort_by { |_, v| -v }.to_h,
  field_completeness: field_completeness,
  complete_required_rows: complete_required_rows,
  complete_required_rows_pct: complete_required_rows_pct,
  duplicate_emails: duplicate_emails.sort_by { |_, v| -v }.to_h,
  duplicate_applicant_ids: duplicate_applicant_ids.sort_by { |_, v| -v }.to_h,
  status_distribution: status_counts.sort_by { |_, v| -v }.to_h,
  stage_distribution: stage_counts.sort_by { |_, v| -v }.to_h,
  program_distribution: program_counts.sort_by { |_, v| -v }.to_h,
  program_required_completeness: program_required_completeness.sort_by { |_, v| -v[:missing_required_pct] }.to_h,
  blank_status: blank_status,
  blank_stage: blank_stage,
  blank_program: blank_program,
  score_stats: score_stats,
  submission_window: submission_window,
  recent_submissions: recent_submissions,
  recent_submission_window_days: options[:recent_days],
  stale_submission_window_days: options[:stale_days],
  invalid_email_count: invalid_email_count,
  invalid_score_count: invalid_score_count,
  score_out_of_range_count: score_out_of_range_count,
  invalid_submitted_at_count: invalid_submitted_at_count,
  future_submissions_count: future_submissions_count,
  stale_submissions_count_180d: stale_submissions_count,
  unknown_status_count: unknown_status_count,
  unknown_stage_count: unknown_stage_count,
  unknown_status_values: unknown_status_values.sort_by { |_, v| -v }.to_h,
  unknown_stage_values: unknown_stage_values.sort_by { |_, v| -v }.to_h,
  issue_count: issue_rows.length,
  issue_samples: issue_rows.first(options[:sample_limit]),
  submission_weekday_distribution: submission_weekday_distribution,
  submission_hour_distribution: submission_hour_distribution
}

if options[:json_path]
  File.write(options[:json_path], JSON.pretty_generate(report))
end

puts "Intake Audit Report"
puts "File: #{report[:file]}"
puts "Generated: #{report[:generated_at]}"
puts "Total rows: #{report[:total_rows]}"

if report[:missing_headers].any?
  puts "Missing headers: #{report[:missing_headers].join(", ")}"
else
  puts "Missing headers: none"
end

if report[:missing_values].any?
  top_missing = report[:missing_values].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top missing values: #{top_missing}"
else
  puts "Top missing values: none"
end

if rows.empty?
  puts "Field completeness: n/a (no rows)"
else
  lowest_coverage = report[:field_completeness].sort_by { |_, v| v[:coverage_pct] }.first(5)
  summary = lowest_coverage.map { |k, v| "#{k} #{v[:coverage_pct]}%" }.join(", ")
  puts "Field completeness (lowest): #{summary}"
end

puts "Complete required rows: #{report[:complete_required_rows]} (#{report[:complete_required_rows_pct]}%)"

if report[:program_required_completeness].any?
  top_program_gaps = report[:program_required_completeness].first(3).map do |program, stats|
    "#{program} #{stats[:missing_required_pct]}% missing"
  end
  puts "Program required gaps (top): #{top_program_gaps.join(", ")}"
end

if report[:duplicate_emails].any?
  puts "Duplicate emails: #{report[:duplicate_emails].length}"
else
  puts "Duplicate emails: none"
end

if report[:duplicate_applicant_ids].any?
  puts "Duplicate applicant IDs: #{report[:duplicate_applicant_ids].length}"
else
  puts "Duplicate applicant IDs: none"
end

puts "Blank status: #{report[:blank_status]}"
puts "Blank stage: #{report[:blank_stage]}"
puts "Blank program: #{report[:blank_program]}"
puts "Invalid emails: #{report[:invalid_email_count]}"
puts "Invalid scores: #{report[:invalid_score_count]}"
puts "Scores out of range: #{report[:score_out_of_range_count]}"
puts "Invalid submitted_at: #{report[:invalid_submitted_at_count]}"
puts "Future submissions: #{report[:future_submissions_count]}"
puts "Stale submissions (#{report[:stale_submission_window_days]}d): #{report[:stale_submissions_count_180d]}"
puts "Unknown statuses: #{report[:unknown_status_count]}"
puts "Unknown stages: #{report[:unknown_stage_count]}"

if report[:score_stats]
  puts "Score stats: min #{report[:score_stats][:min]}, avg #{report[:score_stats][:avg]}, max #{report[:score_stats][:max]}"
else
  puts "Score stats: none"
end

if report[:submission_window]
  puts "Submission window: #{report[:submission_window][:earliest]} -> #{report[:submission_window][:latest]}"
else
  puts "Submission window: none"
end

puts "Recent submissions (#{report[:recent_submission_window_days]}d): #{report[:recent_submissions]}"
if report[:program_distribution].any?
  top_programs = report[:program_distribution].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top programs: #{top_programs}"
else
  puts "Top programs: none"
end

if report[:submission_weekday_distribution].any?
  top_days = report[:submission_weekday_distribution].sort_by { |_, v| -v }.first(3)
  day_summary = top_days.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top submission days: #{day_summary}"
end

if report[:submission_hour_distribution].any?
  top_hours = report[:submission_hour_distribution].sort_by { |_, v| -v }.first(3)
  hour_summary = top_hours.map { |k, v| "#{k}:00=#{v}" }.join(", ")
  puts "Top submission hours: #{hour_summary}"
end

puts "Issue rows: #{report[:issue_count]}"

if report[:issue_samples].any?
  puts "Sample issues:"
  report[:issue_samples].each do |issue|
    puts "- Row #{issue[:row]} (#{issue[:applicant_id] || "n/a"}): #{issue[:issues].join(", ")}"
  end
end

if options[:json_path]
  puts "JSON report: #{File.expand_path(options[:json_path])}"
end
