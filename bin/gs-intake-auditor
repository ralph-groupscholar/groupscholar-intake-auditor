#!/usr/bin/env ruby

require "csv"
require "json"
require "optparse"
require "securerandom"
require "time"
require "date"

options = {
  json_path: nil,
  sample_limit: 10,
  required_headers: nil,
  recent_days: 7,
  stale_days: 180,
  trend_days: 14,
  trend_weeks: 12,
  trend_months: 6,
  status_allowlist: nil,
  stage_allowlist: nil,
  db_log: false,
  now: nil
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: gs-intake-auditor <csv_path> [options]"

  opts.on("--json PATH", "Write full report JSON to PATH") do |path|
    options[:json_path] = path
  end

  opts.on("--sample N", Integer, "Max issue sample rows to show (default: 10)") do |n|
    options[:sample_limit] = [n, 0].max
  end

  opts.on("--require HEADERS", "Comma-separated required headers (override defaults)") do |value|
    headers = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:required_headers] = headers unless headers.empty?
  end

  opts.on("--recent-days N", Integer, "Days to count as recent submissions (default: 7)") do |n|
    options[:recent_days] = [n, 0].max
  end

  opts.on("--stale-days N", Integer, "Days to flag as stale submissions (default: 180)") do |n|
    options[:stale_days] = [n, 0].max
  end

  opts.on("--trend-days N", Integer, "Days to show in submission trend (default: 14)") do |n|
    options[:trend_days] = [n, 0].max
  end

  opts.on("--trend-weeks N", Integer, "Weeks to show in submission trend (default: 12)") do |n|
    options[:trend_weeks] = [n, 0].max
  end

  opts.on("--trend-months N", Integer, "Months to show in submission trend (default: 6)") do |n|
    options[:trend_months] = [n, 0].max
  end

  opts.on("--status-allowlist VALUES", "Comma-separated allowed statuses (flags unknown values)") do |value|
    statuses = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:status_allowlist] = statuses unless statuses.empty?
  end

  opts.on("--stage-allowlist VALUES", "Comma-separated allowed stages (flags unknown values)") do |value|
    stages = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:stage_allowlist] = stages unless stages.empty?
  end

  opts.on("--now TIMESTAMP", "Override current time (ISO8601)") do |value|
    begin
      options[:now] = Time.parse(value.to_s)
    rescue ArgumentError
      warn "Invalid --now timestamp: #{value}"
      exit 1
    end
  end

  opts.on("-h", "--help", "Show help") do
    puts opts
    exit 0
  end

  opts.on("--db-log", "Write audit summary to Postgres via GS_INTAKE_AUDITOR_DATABASE_URL or DATABASE_URL") do
    options[:db_log] = true
  end
end

parser.parse!

csv_path = ARGV.shift
if csv_path.nil? || csv_path.strip.empty?
  warn "Missing CSV path."
  puts parser
  exit 1
end

unless File.exist?(csv_path)
  warn "CSV not found: #{csv_path}"
  exit 1
end

default_required_headers = %w[applicant_id name email program submitted_at status stage score]
required_headers = options[:required_headers] || default_required_headers

rows = []
headers = nil

begin
  CSV.foreach(csv_path, headers: true) do |row|
    headers ||= row.headers
    rows << row
  end
rescue CSV::MalformedCSVError => e
  warn "CSV parse error: #{e.message}"
  exit 1
end

headers ||= []
missing_headers = required_headers - headers
required_headers_in_file = required_headers & headers

missing_values = Hash.new(0)
status_counts = Hash.new(0)
stage_counts = Hash.new(0)
program_counts = Hash.new(0)
program_required_stats = {}
status_stage_distribution = Hash.new { |hash, key| hash[key] = Hash.new(0) }
program_status_distribution = Hash.new { |hash, key| hash[key] = Hash.new(0) }
email_counts = Hash.new(0)
email_domain_counts = Hash.new(0)
applicant_id_counts = Hash.new(0)
stale_submissions_by_program = Hash.new(0)
recent_submissions_by_program = Hash.new(0)
recency_buckets_by_program = Hash.new { |hash, key| hash[key] = Hash.new(0) }
unknown_status_values = Hash.new(0)
unknown_stage_values = Hash.new(0)
score_values = []
score_values_by_program = Hash.new { |hash, key| hash[key] = [] }
score_values_by_status = Hash.new { |hash, key| hash[key] = [] }
score_band_counts = Hash.new(0)
score_band_counts_by_program = Hash.new { |hash, key| hash[key] = Hash.new(0) }
score_band_counts_by_status = Hash.new { |hash, key| hash[key] = Hash.new(0) }
missing_scores_by_program = Hash.new(0)
missing_scores_by_status = Hash.new(0)
submission_times = []
submission_weekday_counts = Hash.new(0)
submission_hour_counts = Hash.new(0)
daily_trend_counts = Hash.new(0)
weekly_trend_counts = Hash.new(0)
monthly_trend_counts = Hash.new(0)
submission_age_by_status_values = Hash.new { |hash, key| hash[key] = [] }
submission_age_stale_counts = Hash.new(0)
submission_age_recent_counts = Hash.new(0)
issue_rows = []
issue_type_counts = Hash.new(0)
issue_rows_with_multiple_issues = 0
blank_status = 0
blank_stage = 0
blank_program = 0
invalid_email_count = 0
invalid_score_count = 0
score_out_of_range_count = 0
invalid_submitted_at_count = 0
future_submissions_count = 0
stale_submissions_count = 0
unknown_status_count = 0
unknown_stage_count = 0
complete_required_rows = 0
submission_age_days = []

email_regex = /\A[^@\s]+@[^@\s]+\.[^@\s]+\z/
now = options[:now] || Time.now
today = now.to_date
recent_cutoff = now - (options[:recent_days] * 24 * 60 * 60)
stale_cutoff = now - (options[:stale_days] * 24 * 60 * 60)
recent_submissions = 0
recency_buckets = Hash.new(0)
recency_bucket_limits = [7, 30, 90, 180]
trend_days_start = today - ([options[:trend_days], 1].max - 1)
current_week_start = today - ((today.wday + 6) % 7)
trend_weeks_start = current_week_start - (7 * ([options[:trend_weeks], 1].max - 1))
current_month_start = Date.new(today.year, today.month, 1)
trend_months_start = current_month_start << ([options[:trend_months], 1].max - 1)

rows.each_with_index do |row, index|
  row_number = index + 2
  issues = []
  missing_required = false
  missing_fields = []
  parsed_submitted_at = nil

  status = row["status"].to_s.strip
  stage = row["stage"].to_s.strip
  program = row["program"].to_s.strip

  required_headers_in_file.each do |header|
    value = row[header]
    if value.nil? || value.strip.empty?
      missing_values[header] += 1
      issues << "missing_#{header}"
      missing_required = true
      missing_fields << header
    end
  end
  complete_required_rows += 1 unless missing_required

  email = row["email"].to_s.strip
  if !email.empty?
    email_counts[email.downcase] += 1
    if email_regex.match?(email)
      domain = email.split("@", 2)[1].to_s.downcase
      email_domain_counts[domain] += 1 unless domain.empty?
    else
      invalid_email_count += 1
      issues << "invalid_email"
    end
  end

  applicant_id = row["applicant_id"].to_s.strip
  applicant_id_counts[applicant_id] += 1 unless applicant_id.empty?

  score_raw = row["score"].to_s.strip
  if score_raw.empty?
    missing_scores_by_program[program] += 1 unless program.to_s.strip.empty?
    missing_scores_by_status[status] += 1 unless status.to_s.strip.empty?
  else
    begin
      score = Float(score_raw)
      score_values << score
      score_values_by_program[program] << score unless program.to_s.strip.empty?
      score_values_by_status[status] << score unless status.to_s.strip.empty?
      if score.between?(0, 100)
        band = case score
               when 0..59 then "0-59"
               when 60..69 then "60-69"
               when 70..79 then "70-79"
               when 80..89 then "80-89"
               when 90..100 then "90-100"
               end
        if band
          score_band_counts[band] += 1
          score_band_counts_by_program[program][band] += 1 unless program.to_s.strip.empty?
          score_band_counts_by_status[status][band] += 1 unless status.to_s.strip.empty?
        end
      else
        score_out_of_range_count += 1
        issues << "score_out_of_range"
      end
    rescue ArgumentError
      invalid_score_count += 1
      issues << "invalid_score"
    end
  end

  submitted_at_raw = row["submitted_at"].to_s.strip
  unless submitted_at_raw.empty?
    begin
      parsed_submitted_at = Time.parse(submitted_at_raw)
      submission_times << parsed_submitted_at
      submission_weekday_counts[parsed_submitted_at.strftime("%A")] += 1
      submission_hour_counts[parsed_submitted_at.strftime("%H")] += 1
      recent_submissions += 1 if parsed_submitted_at >= recent_cutoff
      recent_submissions_by_program[program] += 1 if !program.to_s.strip.empty? && parsed_submitted_at >= recent_cutoff
      submission_date = parsed_submitted_at.to_date
      if submission_date >= trend_days_start
        daily_trend_counts[submission_date.iso8601] += 1
      end
      week_start = submission_date - ((submission_date.wday + 6) % 7)
      if week_start >= trend_weeks_start
        weekly_trend_counts[week_start.iso8601] += 1
      end
      month_start = Date.new(submission_date.year, submission_date.month, 1)
      if month_start >= trend_months_start
        monthly_trend_counts[month_start.iso8601] += 1
      end
      age_days = (now - parsed_submitted_at) / (24 * 60 * 60)
      submission_age_days << age_days
      unless status.empty?
        submission_age_by_status_values[status] << age_days
        submission_age_recent_counts[status] += 1 if parsed_submitted_at >= recent_cutoff
        submission_age_stale_counts[status] += 1 if parsed_submitted_at < stale_cutoff
      end
      bucket_label = recency_bucket_limits.find { |limit| age_days <= limit }
      bucket_key = (bucket_label ? "age_#{bucket_label}d" : "age_over_180d")
      recency_buckets[bucket_key] += 1
      recency_buckets_by_program[program][bucket_key] += 1 unless program.to_s.strip.empty?
      if parsed_submitted_at > now
        future_submissions_count += 1
        issues << "submitted_at_in_future"
      end
      if parsed_submitted_at < stale_cutoff
        stale_submissions_count += 1
        issues << "submitted_at_stale"
      end
    rescue ArgumentError
      invalid_submitted_at_count += 1
      issues << "invalid_submitted_at"
    end
  end

  if status.empty?
    blank_status += 1
  else
    status_counts[status] += 1
    if options[:status_allowlist] && !options[:status_allowlist].include?(status)
      unknown_status_count += 1
      unknown_status_values[status] += 1
      issues << "unknown_status"
    end
  end

  if stage.empty?
    blank_stage += 1
  else
    stage_counts[stage] += 1
    if options[:stage_allowlist] && !options[:stage_allowlist].include?(stage)
      unknown_stage_count += 1
      unknown_stage_values[stage] += 1
      issues << "unknown_stage"
    end
  end

  if program.empty?
    blank_program += 1
  else
    program_counts[program] += 1
    program_status_distribution[program][status] += 1 unless status.empty?
    if parsed_submitted_at && parsed_submitted_at < stale_cutoff
      stale_submissions_by_program[program] += 1
    end
    program_stats = program_required_stats[program] ||= {
      total_rows: 0,
      missing_required_rows: 0,
      missing_required_fields: Hash.new(0)
    }
    program_stats[:total_rows] += 1
    if missing_required
      program_stats[:missing_required_rows] += 1
      missing_fields.each { |field| program_stats[:missing_required_fields][field] += 1 }
    end
  end

  if !status.empty? && !stage.empty?
    status_stage_distribution[status][stage] += 1
  end

  unless issues.empty?
    issues.each { |issue| issue_type_counts[issue] += 1 }
    issue_rows_with_multiple_issues += 1 if issues.length > 1
    issue_rows << {
      row: row_number,
      applicant_id: row["applicant_id"],
      issues: issues
    }
  end
end

duplicate_emails = email_counts.select { |_email, count| count > 1 }
duplicate_applicant_ids = applicant_id_counts.select { |_id, count| count > 1 }

def percentile(values, pct)
  return nil if values.empty?
  sorted = values.sort
  rank = (pct * (sorted.length - 1)).round
  sorted[rank]
end

score_stats = if score_values.empty?
  nil
else
  total = score_values.sum
  {
    min: score_values.min,
    max: score_values.max,
    avg: (total / score_values.length.to_f).round(2),
    p50: percentile(score_values, 0.50),
    p90: percentile(score_values, 0.90),
    p95: percentile(score_values, 0.95)
  }
end

submission_window = if submission_times.empty?
  nil
else
  {
    earliest: submission_times.min.iso8601,
    latest: submission_times.max.iso8601
  }
end

submission_age_stats = if submission_age_days.empty?
  nil
else
  total = submission_age_days.sum
  {
    min_days: submission_age_days.min.round(2),
    max_days: submission_age_days.max.round(2),
    avg_days: (total / submission_age_days.length.to_f).round(2),
    p50_days: percentile(submission_age_days, 0.50)&.round(2),
    p90_days: percentile(submission_age_days, 0.90)&.round(2),
    p95_days: percentile(submission_age_days, 0.95)&.round(2)
  }
end

submission_gap_stats = if submission_times.empty?
  nil
else
  sorted_times = submission_times.sort
  gaps = sorted_times.each_cons(2).map { |start_time, end_time| (end_time - start_time) / (24 * 60 * 60) }
  last_gap = (now - sorted_times.last) / (24 * 60 * 60)
  {
    min_days: gaps.empty? ? nil : gaps.min.round(2),
    max_days: gaps.empty? ? nil : gaps.max.round(2),
    avg_days: gaps.empty? ? nil : (gaps.sum / gaps.length.to_f).round(2),
    last_gap_days: last_gap.round(2)
  }
end

submission_age_by_status = submission_age_by_status_values.map do |status, ages|
  total = ages.sum
  [
    status,
    {
      count: ages.length,
      min_days: ages.min.round(2),
      max_days: ages.max.round(2),
      avg_days: (total / ages.length.to_f).round(2),
      p50_days: percentile(ages, 0.50)&.round(2),
      p90_days: percentile(ages, 0.90)&.round(2),
      p95_days: percentile(ages, 0.95)&.round(2),
      stale_count: submission_age_stale_counts[status] || 0,
      recent_count: submission_age_recent_counts[status] || 0
    }
  ]
end.to_h
submission_age_by_status = submission_age_by_status.sort_by { |_, stats| -stats[:avg_days] }.to_h

complete_required_rows_pct = rows.empty? ? 0.0 : (complete_required_rows * 100.0 / rows.length).round(1)
issue_rows_with_multiple_issues_pct = rows.empty? ? 0.0 : (issue_rows_with_multiple_issues * 100.0 / rows.length).round(1)
weekday_order = %w[Monday Tuesday Wednesday Thursday Friday Saturday Sunday]
submission_weekday_distribution = weekday_order.each_with_object({}) do |day, acc|
  count = submission_weekday_counts[day]
  acc[day] = count if count.positive?
end
submission_hour_distribution = submission_hour_counts.sort_by { |k, _| k }.to_h
submission_daily_trend = if options[:trend_days] <= 0
  {}
else
  (0...options[:trend_days]).each_with_object({}) do |offset, acc|
    day = trend_days_start + offset
    key = day.iso8601
    acc[key] = daily_trend_counts[key] || 0
  end
end
submission_weekly_trend = if options[:trend_weeks] <= 0
  {}
else
  (0...options[:trend_weeks]).each_with_object({}) do |offset, acc|
    week_start = trend_weeks_start + (7 * offset)
    key = week_start.iso8601
    acc[key] = weekly_trend_counts[key] || 0
  end
end
submission_monthly_trend = if options[:trend_months] <= 0
  {}
else
  (0...options[:trend_months]).each_with_object({}) do |offset, acc|
    month_start = trend_months_start >> offset
    key = month_start.iso8601
    acc[key] = monthly_trend_counts[key] || 0
  end
end

score_band_order = ["0-59", "60-69", "70-79", "80-89", "90-100"]
score_band_distribution = score_band_order.each_with_object({}) do |band, acc|
  count = score_band_counts[band]
  acc[band] = count if count.positive?
end
score_band_by_program = score_band_counts_by_program.map do |program, bands|
  ordered = score_band_order.each_with_object({}) do |band, acc|
    count = bands[band]
    acc[band] = count if count.positive?
  end
  [program, ordered]
end.to_h
score_band_by_program = score_band_by_program.sort_by { |_, bands| -bands.values.sum }.to_h
score_band_by_status = score_band_counts_by_status.map do |status, bands|
  ordered = score_band_order.each_with_object({}) do |band, acc|
    count = bands[band]
    acc[band] = count if count.positive?
  end
  [status, ordered]
end.to_h
score_band_by_status = score_band_by_status.sort_by { |_, bands| -bands.values.sum }.to_h

field_completeness = {}
required_headers_in_file.each do |header|
  missing_count = missing_values[header] || 0
  present_count = rows.length - missing_count
  coverage = rows.empty? ? 0.0 : (present_count * 100.0 / rows.length).round(1)
  field_completeness[header] = {
    missing: missing_count,
    present: present_count,
    coverage_pct: coverage
  }
end

program_required_completeness = program_required_stats.map do |program, stats|
  total = stats[:total_rows]
  missing = stats[:missing_required_rows]
  coverage_pct = total.zero? ? 0.0 : ((total - missing) * 100.0 / total).round(1)
  top_missing_fields = stats[:missing_required_fields].sort_by { |_, v| -v }.to_h
  [
    program,
    {
      total_rows: total,
      missing_required_rows: missing,
      missing_required_pct: total.zero? ? 0.0 : (missing * 100.0 / total).round(1),
      coverage_pct: coverage_pct,
      missing_required_fields: top_missing_fields
    }
  ]
end.to_h

status_stage_distribution_sorted = status_stage_distribution.map do |status, stages|
  [status, stages.sort_by { |_, v| -v }.to_h]
end.sort_by { |_, stages| -stages.values.sum }.to_h

program_status_distribution_sorted = program_status_distribution.map do |program, statuses|
  [program, statuses.sort_by { |_, v| -v }.to_h]
end.sort_by { |_, statuses| -statuses.values.sum }.to_h

report = {
  file: File.expand_path(csv_path),
  generated_at: now.iso8601,
  total_rows: rows.length,
  headers: headers,
  missing_headers: missing_headers,
  missing_values: missing_values.sort_by { |_, v| -v }.to_h,
  field_completeness: field_completeness,
  complete_required_rows: complete_required_rows,
  complete_required_rows_pct: complete_required_rows_pct,
  duplicate_emails: duplicate_emails.sort_by { |_, v| -v }.to_h,
  email_domain_distribution: email_domain_counts.sort_by { |_, v| -v }.to_h,
  duplicate_applicant_ids: duplicate_applicant_ids.sort_by { |_, v| -v }.to_h,
  status_distribution: status_counts.sort_by { |_, v| -v }.to_h,
  stage_distribution: stage_counts.sort_by { |_, v| -v }.to_h,
  program_distribution: program_counts.sort_by { |_, v| -v }.to_h,
  program_required_completeness: program_required_completeness.sort_by { |_, v| -v[:missing_required_pct] }.to_h,
  status_stage_distribution: status_stage_distribution_sorted,
  program_status_distribution: program_status_distribution_sorted,
  blank_status: blank_status,
  blank_stage: blank_stage,
  blank_program: blank_program,
  score_stats: score_stats,
  score_stats_by_program: score_values_by_program.map { |program, values|
    [program, {
      score_stats: values.empty? ? nil : {
        min: values.min,
        max: values.max,
        avg: (values.sum / values.length.to_f).round(2),
        p50: percentile(values, 0.50),
        p90: percentile(values, 0.90),
        p95: percentile(values, 0.95)
      },
      missing_scores: missing_scores_by_program[program] || 0
    }]
  }.to_h,
  score_stats_by_status: score_values_by_status.map { |status, values|
    [status, {
      score_stats: values.empty? ? nil : {
        min: values.min,
        max: values.max,
        avg: (values.sum / values.length.to_f).round(2),
        p50: percentile(values, 0.50),
        p90: percentile(values, 0.90),
        p95: percentile(values, 0.95)
      },
      missing_scores: missing_scores_by_status[status] || 0
    }]
  }.to_h,
  score_band_distribution: score_band_distribution,
  score_band_by_program: score_band_by_program,
  score_band_by_status: score_band_by_status,
  submission_window: submission_window,
  submission_age_days_stats: submission_age_stats,
  submission_gap_stats: submission_gap_stats,
  submission_age_by_status: submission_age_by_status,
  recent_submissions: recent_submissions,
  recent_submissions_by_program: recent_submissions_by_program.sort_by { |_, v| -v }.to_h,
  recent_submission_window_days: options[:recent_days],
  stale_submission_window_days: options[:stale_days],
  invalid_email_count: invalid_email_count,
  invalid_score_count: invalid_score_count,
  score_out_of_range_count: score_out_of_range_count,
  invalid_submitted_at_count: invalid_submitted_at_count,
  future_submissions_count: future_submissions_count,
  stale_submissions_count_180d: stale_submissions_count,
  stale_submissions_by_program: stale_submissions_by_program.sort_by { |_, v| -v }.to_h,
  unknown_status_count: unknown_status_count,
  unknown_stage_count: unknown_stage_count,
  unknown_status_values: unknown_status_values.sort_by { |_, v| -v }.to_h,
  unknown_stage_values: unknown_stage_values.sort_by { |_, v| -v }.to_h,
  issue_count: issue_rows.length,
  issue_type_counts: issue_type_counts.sort_by { |_, v| -v }.to_h,
  issue_rows_with_multiple_issues: issue_rows_with_multiple_issues,
  issue_rows_with_multiple_issues_pct: issue_rows_with_multiple_issues_pct,
  issue_samples: issue_rows.first(options[:sample_limit]),
  submission_weekday_distribution: submission_weekday_distribution,
  submission_hour_distribution: submission_hour_distribution,
  submission_recency_buckets: recency_buckets.sort_by { |_, v| -v }.to_h,
  submission_recency_by_program: recency_buckets_by_program.transform_values { |buckets|
    buckets.sort_by { |_, v| -v }.to_h
  }.sort_by { |_, buckets| -buckets.values.sum }.to_h,
  submission_daily_trend: submission_daily_trend,
  submission_weekly_trend: submission_weekly_trend,
  submission_monthly_trend: submission_monthly_trend
}

def log_report_to_db(report, db_url)
  begin
    require "pg"
  rescue LoadError
    warn "pg gem missing. Install with: gem install pg"
    return nil
  end

  conn = PG.connect(db_url)
  run_id = SecureRandom.uuid
  sql = <<~SQL
    INSERT INTO intake_auditor.audit_runs (
      id,
      generated_at,
      file_path,
      total_rows,
      missing_headers,
      missing_values,
      field_completeness,
      complete_required_rows,
      complete_required_rows_pct,
      duplicate_emails,
      duplicate_applicant_ids,
      status_distribution,
      stage_distribution,
      program_distribution,
      program_required_completeness,
      score_stats,
      score_stats_by_program,
      score_stats_by_status,
      score_band_distribution,
      score_band_by_program,
      score_band_by_status,
      submission_window,
      submission_age_days_stats,
      submission_gap_stats,
      submission_age_by_status,
      recent_submissions,
      recent_submissions_by_program,
      recent_submission_window_days,
      stale_submission_window_days,
      invalid_email_count,
      invalid_score_count,
      score_out_of_range_count,
      invalid_submitted_at_count,
      future_submissions_count,
      stale_submissions_count,
      stale_submissions_by_program,
      unknown_status_count,
      unknown_stage_count,
      blank_status,
      blank_stage,
      blank_program,
      email_domain_distribution,
      status_stage_distribution,
      program_status_distribution,
      submission_weekday_distribution,
      submission_hour_distribution,
      submission_recency_buckets,
      submission_recency_by_program,
      submission_daily_trend,
      submission_weekly_trend,
      submission_monthly_trend,
      issue_count
    ) VALUES (
      $1, $2, $3, $4, $5::jsonb, $6::jsonb, $7::jsonb, $8, $9, $10::jsonb, $11::jsonb, $12::jsonb,
      $13::jsonb, $14::jsonb, $15::jsonb, $16::jsonb, $17::jsonb, $18::jsonb, $19::jsonb, $20::jsonb, $21::jsonb,
      $22::jsonb, $23, $24::jsonb, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34::jsonb, $35, $36, $37,
      $38, $39, $40::jsonb, $41::jsonb, $42::jsonb, $43::jsonb, $44::jsonb, $45::jsonb, $46::jsonb, $47::jsonb,
      $48::jsonb, $49::jsonb, $50::jsonb, $51
    )
  SQL
  params = [
    run_id,
    report[:generated_at],
    report[:file],
    report[:total_rows],
    JSON.dump(report[:missing_headers]),
    JSON.dump(report[:missing_values]),
    JSON.dump(report[:field_completeness]),
    report[:complete_required_rows],
    report[:complete_required_rows_pct],
    JSON.dump(report[:duplicate_emails]),
    JSON.dump(report[:duplicate_applicant_ids]),
    JSON.dump(report[:status_distribution]),
    JSON.dump(report[:stage_distribution]),
    JSON.dump(report[:program_distribution]),
    JSON.dump(report[:program_required_completeness]),
    JSON.dump(report[:score_stats]),
    JSON.dump(report[:score_stats_by_program]),
    JSON.dump(report[:score_stats_by_status]),
    JSON.dump(report[:score_band_distribution]),
    JSON.dump(report[:score_band_by_program]),
    JSON.dump(report[:score_band_by_status]),
    JSON.dump(report[:submission_window]),
    JSON.dump(report[:submission_age_days_stats]),
    JSON.dump(report[:submission_gap_stats]),
    JSON.dump(report[:submission_age_by_status]),
    report[:recent_submissions],
    JSON.dump(report[:recent_submissions_by_program]),
    report[:recent_submission_window_days],
    report[:stale_submission_window_days],
    report[:invalid_email_count],
    report[:invalid_score_count],
    report[:score_out_of_range_count],
    report[:invalid_submitted_at_count],
    report[:future_submissions_count],
    report[:stale_submissions_count_180d],
    JSON.dump(report[:stale_submissions_by_program]),
    report[:unknown_status_count],
    report[:unknown_stage_count],
    report[:blank_status],
    report[:blank_stage],
    report[:blank_program],
    JSON.dump(report[:email_domain_distribution]),
    JSON.dump(report[:status_stage_distribution]),
    JSON.dump(report[:program_status_distribution]),
    JSON.dump(report[:submission_weekday_distribution]),
    JSON.dump(report[:submission_hour_distribution]),
    JSON.dump(report[:submission_recency_buckets]),
    JSON.dump(report[:submission_recency_by_program]),
    JSON.dump(report[:submission_daily_trend]),
    JSON.dump(report[:submission_weekly_trend]),
    JSON.dump(report[:submission_monthly_trend]),
    report[:issue_count]
  ]
  conn.exec_params(sql, params)
  run_id
ensure
  conn&.close
end

if options[:json_path]
  File.write(options[:json_path], JSON.pretty_generate(report))
end

if options[:db_log]
  db_url = ENV["GS_INTAKE_AUDITOR_DATABASE_URL"] || ENV["DATABASE_URL"]
  if db_url.nil? || db_url.strip.empty?
    warn "DB log requested but GS_INTAKE_AUDITOR_DATABASE_URL/DATABASE_URL not set."
  else
    run_id = log_report_to_db(report, db_url)
    puts "DB log id: #{run_id}" if run_id
  end
end

puts "Intake Audit Report"
puts "File: #{report[:file]}"
puts "Generated: #{report[:generated_at]}"
puts "Total rows: #{report[:total_rows]}"

if report[:missing_headers].any?
  puts "Missing headers: #{report[:missing_headers].join(", ")}"
else
  puts "Missing headers: none"
end

if report[:missing_values].any?
  top_missing = report[:missing_values].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top missing values: #{top_missing}"
else
  puts "Top missing values: none"
end

if rows.empty?
  puts "Field completeness: n/a (no rows)"
else
  lowest_coverage = report[:field_completeness].sort_by { |_, v| v[:coverage_pct] }.first(5)
  summary = lowest_coverage.map { |k, v| "#{k} #{v[:coverage_pct]}%" }.join(", ")
  puts "Field completeness (lowest): #{summary}"
end

puts "Complete required rows: #{report[:complete_required_rows]} (#{report[:complete_required_rows_pct]}%)"

if report[:program_required_completeness].any?
  top_program_gaps = report[:program_required_completeness].first(3).map do |program, stats|
    "#{program} #{stats[:missing_required_pct]}% missing"
  end
  puts "Program required gaps (top): #{top_program_gaps.join(", ")}"
end

if report[:duplicate_emails].any?
  puts "Duplicate emails: #{report[:duplicate_emails].length}"
else
  puts "Duplicate emails: none"
end

if report[:email_domain_distribution].any?
  top_domains = report[:email_domain_distribution].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top email domains: #{top_domains}"
else
  puts "Top email domains: none"
end

if report[:duplicate_applicant_ids].any?
  puts "Duplicate applicant IDs: #{report[:duplicate_applicant_ids].length}"
else
  puts "Duplicate applicant IDs: none"
end

puts "Blank status: #{report[:blank_status]}"
puts "Blank stage: #{report[:blank_stage]}"
puts "Blank program: #{report[:blank_program]}"
puts "Invalid emails: #{report[:invalid_email_count]}"
puts "Invalid scores: #{report[:invalid_score_count]}"
puts "Scores out of range: #{report[:score_out_of_range_count]}"
puts "Invalid submitted_at: #{report[:invalid_submitted_at_count]}"
puts "Future submissions: #{report[:future_submissions_count]}"
puts "Stale submissions (#{report[:stale_submission_window_days]}d): #{report[:stale_submissions_count_180d]}"
if report[:stale_submissions_by_program].any?
  top_stale_programs = report[:stale_submissions_by_program].first(3).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Stale submissions by program (top): #{top_stale_programs}"
end
puts "Unknown statuses: #{report[:unknown_status_count]}"
puts "Unknown stages: #{report[:unknown_stage_count]}"

if report[:score_stats]
  stats = report[:score_stats]
  puts "Score stats: min #{stats[:min]}, avg #{stats[:avg]}, max #{stats[:max]}, p50 #{stats[:p50]}, p90 #{stats[:p90]}, p95 #{stats[:p95]}"
else
  puts "Score stats: none"
end

if report[:score_band_distribution].any?
  band_summary = report[:score_band_distribution].map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Score bands: #{band_summary}"
end

if report[:submission_window]
  puts "Submission window: #{report[:submission_window][:earliest]} -> #{report[:submission_window][:latest]}"
else
  puts "Submission window: none"
end

if report[:submission_age_days_stats]
  stats = report[:submission_age_days_stats]
  puts "Submission age (days): min #{stats[:min_days]}, avg #{stats[:avg_days]}, max #{stats[:max_days]}, p50 #{stats[:p50_days]}, p90 #{stats[:p90_days]}, p95 #{stats[:p95_days]}"
end

if report[:submission_age_by_status].any?
  top_status_age = report[:submission_age_by_status].first(3).map do |status, stats|
    "#{status}=#{stats[:avg_days]}d avg (#{stats[:count]})"
  end
  puts "Status age (top avg): #{top_status_age.join(", ")}"
  top_stale = report[:submission_age_by_status].sort_by { |_, stats| -stats[:stale_count] }
  top_stale = top_stale.first(3).select { |_, stats| stats[:stale_count].positive? }
  if top_stale.any?
    stale_summary = top_stale.map { |status, stats| "#{status}=#{stats[:stale_count]}" }.join(", ")
    puts "Stale submissions by status: #{stale_summary}"
  end
end

if report[:submission_gap_stats]
  stats = report[:submission_gap_stats]
  if stats[:min_days]
    puts "Submission gaps (days): min #{stats[:min_days]}, avg #{stats[:avg_days]}, max #{stats[:max_days]}, since latest #{stats[:last_gap_days]}"
  else
    puts "Submission gaps (days): only one submission, since latest #{stats[:last_gap_days]}"
  end
end

puts "Recent submissions (#{report[:recent_submission_window_days]}d): #{report[:recent_submissions]}"
if report[:submission_recency_buckets].any?
  bucket_summary = report[:submission_recency_buckets].map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Submission recency buckets: #{bucket_summary}"
end
if report[:program_distribution].any?
  top_programs = report[:program_distribution].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top programs: #{top_programs}"
else
  puts "Top programs: none"
end

if report[:recent_submissions_by_program].any?
  top_recent = report[:recent_submissions_by_program].first(3).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Recent submissions by program (top): #{top_recent}"
end

if report[:score_stats_by_program].any?
  top_program_scores = report[:score_stats_by_program].filter do |_, stats|
    stats[:score_stats]
  end.map do |program, stats|
    [program, stats[:score_stats][:avg]]
  end.sort_by { |_, avg| -avg }.first(3)
  if top_program_scores.any?
    summary = top_program_scores.map { |program, avg| "#{program}=#{avg}" }.join(", ")
    puts "Top program avg scores: #{summary}"
  end
end

if report[:status_stage_distribution].any?
  top_pairs = report[:status_stage_distribution].flat_map do |status, stages|
    stages.map { |stage, count| ["#{status} -> #{stage}", count] }
  end.sort_by { |_, v| -v }.first(5)
  pair_summary = top_pairs.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top status-stage combos: #{pair_summary}"
else
  puts "Top status-stage combos: none"
end

if report[:program_status_distribution].any?
  top_program_pairs = report[:program_status_distribution].flat_map do |program, statuses|
    statuses.map { |status, count| ["#{program} -> #{status}", count] }
  end.sort_by { |_, v| -v }.first(5)
  program_summary = top_program_pairs.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top program-status combos: #{program_summary}"
else
  puts "Top program-status combos: none"
end

if report[:submission_weekday_distribution].any?
  top_days = report[:submission_weekday_distribution].sort_by { |_, v| -v }.first(3)
  day_summary = top_days.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top submission days: #{day_summary}"
end

if report[:submission_hour_distribution].any?
  top_hours = report[:submission_hour_distribution].sort_by { |_, v| -v }.first(3)
  hour_summary = top_hours.map { |k, v| "#{k}:00=#{v}" }.join(", ")
  puts "Top submission hours: #{hour_summary}"
end

if report[:submission_daily_trend].any?
  trend_summary = report[:submission_daily_trend].map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Submission trend daily (#{options[:trend_days]}d): #{trend_summary}"
end

if report[:submission_weekly_trend].any?
  trend_summary = report[:submission_weekly_trend].map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Submission trend weekly (#{options[:trend_weeks]}w): #{trend_summary}"
end

if report[:submission_monthly_trend].any?
  trend_summary = report[:submission_monthly_trend].map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Submission trend monthly (#{options[:trend_months]}m): #{trend_summary}"
end

puts "Issue rows: #{report[:issue_count]}"
puts "Issue rows with multiple flags: #{report[:issue_rows_with_multiple_issues]} (#{report[:issue_rows_with_multiple_issues_pct]}%)"

if report[:issue_type_counts].any?
  top_issue_types = report[:issue_type_counts].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top issue types: #{top_issue_types}"
end

if report[:issue_samples].any?
  puts "Sample issues:"
  report[:issue_samples].each do |issue|
    puts "- Row #{issue[:row]} (#{issue[:applicant_id] || "n/a"}): #{issue[:issues].join(", ")}"
  end
end

if options[:json_path]
  puts "JSON report: #{File.expand_path(options[:json_path])}"
end
