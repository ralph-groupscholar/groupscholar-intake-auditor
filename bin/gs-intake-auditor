#!/usr/bin/env ruby

require "csv"
require "json"
require "optparse"
require "securerandom"
require "time"

options = {
  json_path: nil,
  sample_limit: 10,
  required_headers: nil,
  recent_days: 7,
  stale_days: 180,
  status_allowlist: nil,
  stage_allowlist: nil,
  db_log: false
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: gs-intake-auditor <csv_path> [options]"

  opts.on("--json PATH", "Write full report JSON to PATH") do |path|
    options[:json_path] = path
  end

  opts.on("--sample N", Integer, "Max issue sample rows to show (default: 10)") do |n|
    options[:sample_limit] = [n, 0].max
  end

  opts.on("--require HEADERS", "Comma-separated required headers (override defaults)") do |value|
    headers = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:required_headers] = headers unless headers.empty?
  end

  opts.on("--recent-days N", Integer, "Days to count as recent submissions (default: 7)") do |n|
    options[:recent_days] = [n, 0].max
  end

  opts.on("--stale-days N", Integer, "Days to flag as stale submissions (default: 180)") do |n|
    options[:stale_days] = [n, 0].max
  end

  opts.on("--status-allowlist VALUES", "Comma-separated allowed statuses (flags unknown values)") do |value|
    statuses = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:status_allowlist] = statuses unless statuses.empty?
  end

  opts.on("--stage-allowlist VALUES", "Comma-separated allowed stages (flags unknown values)") do |value|
    stages = value.to_s.split(",").map(&:strip).reject(&:empty?)
    options[:stage_allowlist] = stages unless stages.empty?
  end

  opts.on("-h", "--help", "Show help") do
    puts opts
    exit 0
  end

  opts.on("--db-log", "Write audit summary to Postgres via GS_INTAKE_AUDITOR_DATABASE_URL or DATABASE_URL") do
    options[:db_log] = true
  end
end

parser.parse!

csv_path = ARGV.shift
if csv_path.nil? || csv_path.strip.empty?
  warn "Missing CSV path."
  puts parser
  exit 1
end

unless File.exist?(csv_path)
  warn "CSV not found: #{csv_path}"
  exit 1
end

default_required_headers = %w[applicant_id name email program submitted_at status stage score]
required_headers = options[:required_headers] || default_required_headers

rows = []
headers = nil

begin
  CSV.foreach(csv_path, headers: true) do |row|
    headers ||= row.headers
    rows << row
  end
rescue CSV::MalformedCSVError => e
  warn "CSV parse error: #{e.message}"
  exit 1
end

headers ||= []
missing_headers = required_headers - headers
required_headers_in_file = required_headers & headers

missing_values = Hash.new(0)
status_counts = Hash.new(0)
stage_counts = Hash.new(0)
program_counts = Hash.new(0)
program_required_stats = {}
status_stage_distribution = Hash.new { |hash, key| hash[key] = Hash.new(0) }
program_status_distribution = Hash.new { |hash, key| hash[key] = Hash.new(0) }
email_counts = Hash.new(0)
email_domain_counts = Hash.new(0)
applicant_id_counts = Hash.new(0)
unknown_status_values = Hash.new(0)
unknown_stage_values = Hash.new(0)
score_values = []
submission_times = []
submission_weekday_counts = Hash.new(0)
submission_hour_counts = Hash.new(0)
issue_rows = []
blank_status = 0
blank_stage = 0
blank_program = 0
invalid_email_count = 0
invalid_score_count = 0
score_out_of_range_count = 0
invalid_submitted_at_count = 0
future_submissions_count = 0
stale_submissions_count = 0
unknown_status_count = 0
unknown_stage_count = 0
complete_required_rows = 0
submission_age_days = []

email_regex = /\A[^@\s]+@[^@\s]+\.[^@\s]+\z/
now = Time.now
recent_cutoff = now - (options[:recent_days] * 24 * 60 * 60)
stale_cutoff = now - (options[:stale_days] * 24 * 60 * 60)
recent_submissions = 0
recency_buckets = Hash.new(0)
recency_bucket_limits = [7, 30, 90, 180]

rows.each_with_index do |row, index|
  row_number = index + 2
  issues = []
  missing_required = false
  missing_fields = []

  required_headers_in_file.each do |header|
    value = row[header]
    if value.nil? || value.strip.empty?
      missing_values[header] += 1
      issues << "missing_#{header}"
      missing_required = true
      missing_fields << header
    end
  end
  complete_required_rows += 1 unless missing_required

  email = row["email"].to_s.strip
  if !email.empty?
    email_counts[email.downcase] += 1
    if email_regex.match?(email)
      domain = email.split("@", 2)[1].to_s.downcase
      email_domain_counts[domain] += 1 unless domain.empty?
    else
      invalid_email_count += 1
      issues << "invalid_email"
    end
  end

  applicant_id = row["applicant_id"].to_s.strip
  applicant_id_counts[applicant_id] += 1 unless applicant_id.empty?

  score_raw = row["score"].to_s.strip
  unless score_raw.empty?
    begin
      score = Float(score_raw)
      score_values << score
      unless score.between?(0, 100)
        score_out_of_range_count += 1
        issues << "score_out_of_range"
      end
    rescue ArgumentError
      invalid_score_count += 1
      issues << "invalid_score"
    end
  end

  submitted_at_raw = row["submitted_at"].to_s.strip
  unless submitted_at_raw.empty?
    begin
      submitted_at = Time.parse(submitted_at_raw)
      submission_times << submitted_at
      submission_weekday_counts[submitted_at.strftime("%A")] += 1
      submission_hour_counts[submitted_at.strftime("%H")] += 1
      recent_submissions += 1 if submitted_at >= recent_cutoff
      age_days = (now - submitted_at) / (24 * 60 * 60)
      submission_age_days << age_days
      bucket_label = recency_bucket_limits.find { |limit| age_days <= limit }
      recency_buckets[(bucket_label ? "age_#{bucket_label}d" : "age_over_180d")] += 1
      if submitted_at > now
        future_submissions_count += 1
        issues << "submitted_at_in_future"
      end
      if submitted_at < stale_cutoff
        stale_submissions_count += 1
        issues << "submitted_at_stale"
      end
    rescue ArgumentError
      invalid_submitted_at_count += 1
      issues << "invalid_submitted_at"
    end
  end

  status = row["status"].to_s.strip
  if status.empty?
    blank_status += 1
  else
    status_counts[status] += 1
    if options[:status_allowlist] && !options[:status_allowlist].include?(status)
      unknown_status_count += 1
      unknown_status_values[status] += 1
      issues << "unknown_status"
    end
  end

  stage = row["stage"].to_s.strip
  if stage.empty?
    blank_stage += 1
  else
    stage_counts[stage] += 1
    if options[:stage_allowlist] && !options[:stage_allowlist].include?(stage)
      unknown_stage_count += 1
      unknown_stage_values[stage] += 1
      issues << "unknown_stage"
    end
  end

  program = row["program"].to_s.strip
  if program.empty?
    blank_program += 1
  else
    program_counts[program] += 1
    program_status_distribution[program][status] += 1 unless status.empty?
    program_stats = program_required_stats[program] ||= {
      total_rows: 0,
      missing_required_rows: 0,
      missing_required_fields: Hash.new(0)
    }
    program_stats[:total_rows] += 1
    if missing_required
      program_stats[:missing_required_rows] += 1
      missing_fields.each { |field| program_stats[:missing_required_fields][field] += 1 }
    end
  end

  if !status.empty? && !stage.empty?
    status_stage_distribution[status][stage] += 1
  end

  issue_rows << {
    row: row_number,
    applicant_id: row["applicant_id"],
    issues: issues
  } unless issues.empty?
end

duplicate_emails = email_counts.select { |_email, count| count > 1 }
duplicate_applicant_ids = applicant_id_counts.select { |_id, count| count > 1 }

def percentile(values, pct)
  return nil if values.empty?
  sorted = values.sort
  rank = (pct * (sorted.length - 1)).round
  sorted[rank]
end

score_stats = if score_values.empty?
  nil
else
  total = score_values.sum
  {
    min: score_values.min,
    max: score_values.max,
    avg: (total / score_values.length.to_f).round(2),
    p50: percentile(score_values, 0.50),
    p90: percentile(score_values, 0.90),
    p95: percentile(score_values, 0.95)
  }
end

submission_window = if submission_times.empty?
  nil
else
  {
    earliest: submission_times.min.iso8601,
    latest: submission_times.max.iso8601
  }
end

submission_age_stats = if submission_age_days.empty?
  nil
else
  total = submission_age_days.sum
  {
    min_days: submission_age_days.min.round(2),
    max_days: submission_age_days.max.round(2),
    avg_days: (total / submission_age_days.length.to_f).round(2),
    p50_days: percentile(submission_age_days, 0.50)&.round(2),
    p90_days: percentile(submission_age_days, 0.90)&.round(2),
    p95_days: percentile(submission_age_days, 0.95)&.round(2)
  }
end

complete_required_rows_pct = rows.empty? ? 0.0 : (complete_required_rows * 100.0 / rows.length).round(1)
weekday_order = %w[Monday Tuesday Wednesday Thursday Friday Saturday Sunday]
submission_weekday_distribution = weekday_order.each_with_object({}) do |day, acc|
  count = submission_weekday_counts[day]
  acc[day] = count if count.positive?
end
submission_hour_distribution = submission_hour_counts.sort_by { |k, _| k }.to_h

field_completeness = {}
required_headers_in_file.each do |header|
  missing_count = missing_values[header] || 0
  present_count = rows.length - missing_count
  coverage = rows.empty? ? 0.0 : (present_count * 100.0 / rows.length).round(1)
  field_completeness[header] = {
    missing: missing_count,
    present: present_count,
    coverage_pct: coverage
  }
end

program_required_completeness = program_required_stats.map do |program, stats|
  total = stats[:total_rows]
  missing = stats[:missing_required_rows]
  coverage_pct = total.zero? ? 0.0 : ((total - missing) * 100.0 / total).round(1)
  top_missing_fields = stats[:missing_required_fields].sort_by { |_, v| -v }.to_h
  [
    program,
    {
      total_rows: total,
      missing_required_rows: missing,
      missing_required_pct: total.zero? ? 0.0 : (missing * 100.0 / total).round(1),
      coverage_pct: coverage_pct,
      missing_required_fields: top_missing_fields
    }
  ]
end.to_h

status_stage_distribution_sorted = status_stage_distribution.map do |status, stages|
  [status, stages.sort_by { |_, v| -v }.to_h]
end.sort_by { |_, stages| -stages.values.sum }.to_h

program_status_distribution_sorted = program_status_distribution.map do |program, statuses|
  [program, statuses.sort_by { |_, v| -v }.to_h]
end.sort_by { |_, statuses| -statuses.values.sum }.to_h

report = {
  file: File.expand_path(csv_path),
  generated_at: now.iso8601,
  total_rows: rows.length,
  headers: headers,
  missing_headers: missing_headers,
  missing_values: missing_values.sort_by { |_, v| -v }.to_h,
  field_completeness: field_completeness,
  complete_required_rows: complete_required_rows,
  complete_required_rows_pct: complete_required_rows_pct,
  duplicate_emails: duplicate_emails.sort_by { |_, v| -v }.to_h,
  email_domain_distribution: email_domain_counts.sort_by { |_, v| -v }.to_h,
  duplicate_applicant_ids: duplicate_applicant_ids.sort_by { |_, v| -v }.to_h,
  status_distribution: status_counts.sort_by { |_, v| -v }.to_h,
  stage_distribution: stage_counts.sort_by { |_, v| -v }.to_h,
  program_distribution: program_counts.sort_by { |_, v| -v }.to_h,
  program_required_completeness: program_required_completeness.sort_by { |_, v| -v[:missing_required_pct] }.to_h,
  status_stage_distribution: status_stage_distribution_sorted,
  program_status_distribution: program_status_distribution_sorted,
  blank_status: blank_status,
  blank_stage: blank_stage,
  blank_program: blank_program,
  score_stats: score_stats,
  submission_window: submission_window,
  submission_age_days_stats: submission_age_stats,
  recent_submissions: recent_submissions,
  recent_submission_window_days: options[:recent_days],
  stale_submission_window_days: options[:stale_days],
  invalid_email_count: invalid_email_count,
  invalid_score_count: invalid_score_count,
  score_out_of_range_count: score_out_of_range_count,
  invalid_submitted_at_count: invalid_submitted_at_count,
  future_submissions_count: future_submissions_count,
  stale_submissions_count_180d: stale_submissions_count,
  unknown_status_count: unknown_status_count,
  unknown_stage_count: unknown_stage_count,
  unknown_status_values: unknown_status_values.sort_by { |_, v| -v }.to_h,
  unknown_stage_values: unknown_stage_values.sort_by { |_, v| -v }.to_h,
  issue_count: issue_rows.length,
  issue_samples: issue_rows.first(options[:sample_limit]),
  submission_weekday_distribution: submission_weekday_distribution,
  submission_hour_distribution: submission_hour_distribution,
  submission_recency_buckets: recency_buckets.sort_by { |_, v| -v }.to_h
}

def log_report_to_db(report, db_url)
  begin
    require "pg"
  rescue LoadError
    warn "pg gem missing. Install with: gem install pg"
    return nil
  end

  conn = PG.connect(db_url)
  run_id = SecureRandom.uuid
  sql = <<~SQL
    INSERT INTO intake_auditor.audit_runs (
      id,
      generated_at,
      file_path,
      total_rows,
      missing_headers,
      missing_values,
      field_completeness,
      complete_required_rows,
      complete_required_rows_pct,
      duplicate_emails,
      duplicate_applicant_ids,
      status_distribution,
      stage_distribution,
      program_distribution,
      program_required_completeness,
      score_stats,
      submission_window,
      submission_age_days_stats,
      recent_submissions,
      recent_submission_window_days,
      stale_submission_window_days,
      invalid_email_count,
      invalid_score_count,
      score_out_of_range_count,
      invalid_submitted_at_count,
      future_submissions_count,
      stale_submissions_count,
      unknown_status_count,
      unknown_stage_count,
      blank_status,
      blank_stage,
      blank_program,
      email_domain_distribution,
      status_stage_distribution,
      program_status_distribution,
      submission_weekday_distribution,
      submission_hour_distribution,
      submission_recency_buckets,
      issue_count
    ) VALUES (
      $1, $2, $3, $4, $5::jsonb, $6::jsonb, $7::jsonb, $8, $9, $10::jsonb, $11::jsonb, $12::jsonb,
      $13::jsonb, $14::jsonb, $15::jsonb, $16::jsonb, $17::jsonb, $18::jsonb, $19, $20, $21, $22,
      $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33::jsonb, $34::jsonb, $35::jsonb, $36::jsonb,
      $37::jsonb, $38::jsonb, $39
    )
  SQL
  params = [
    run_id,
    report[:generated_at],
    report[:file],
    report[:total_rows],
    JSON.dump(report[:missing_headers]),
    JSON.dump(report[:missing_values]),
    JSON.dump(report[:field_completeness]),
    report[:complete_required_rows],
    report[:complete_required_rows_pct],
    JSON.dump(report[:duplicate_emails]),
    JSON.dump(report[:duplicate_applicant_ids]),
    JSON.dump(report[:status_distribution]),
    JSON.dump(report[:stage_distribution]),
    JSON.dump(report[:program_distribution]),
    JSON.dump(report[:program_required_completeness]),
    JSON.dump(report[:score_stats]),
    JSON.dump(report[:submission_window]),
    JSON.dump(report[:submission_age_days_stats]),
    report[:recent_submissions],
    report[:recent_submission_window_days],
    report[:stale_submission_window_days],
    report[:invalid_email_count],
    report[:invalid_score_count],
    report[:score_out_of_range_count],
    report[:invalid_submitted_at_count],
    report[:future_submissions_count],
    report[:stale_submissions_count_180d],
    report[:unknown_status_count],
    report[:unknown_stage_count],
    report[:blank_status],
    report[:blank_stage],
    report[:blank_program],
    JSON.dump(report[:email_domain_distribution]),
    JSON.dump(report[:status_stage_distribution]),
    JSON.dump(report[:program_status_distribution]),
    JSON.dump(report[:submission_weekday_distribution]),
    JSON.dump(report[:submission_hour_distribution]),
    JSON.dump(report[:submission_recency_buckets]),
    report[:issue_count]
  ]
  conn.exec_params(sql, params)
  run_id
ensure
  conn&.close
end

if options[:json_path]
  File.write(options[:json_path], JSON.pretty_generate(report))
end

if options[:db_log]
  db_url = ENV["GS_INTAKE_AUDITOR_DATABASE_URL"] || ENV["DATABASE_URL"]
  if db_url.nil? || db_url.strip.empty?
    warn "DB log requested but GS_INTAKE_AUDITOR_DATABASE_URL/DATABASE_URL not set."
  else
    run_id = log_report_to_db(report, db_url)
    puts "DB log id: #{run_id}" if run_id
  end
end

puts "Intake Audit Report"
puts "File: #{report[:file]}"
puts "Generated: #{report[:generated_at]}"
puts "Total rows: #{report[:total_rows]}"

if report[:missing_headers].any?
  puts "Missing headers: #{report[:missing_headers].join(", ")}"
else
  puts "Missing headers: none"
end

if report[:missing_values].any?
  top_missing = report[:missing_values].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top missing values: #{top_missing}"
else
  puts "Top missing values: none"
end

if rows.empty?
  puts "Field completeness: n/a (no rows)"
else
  lowest_coverage = report[:field_completeness].sort_by { |_, v| v[:coverage_pct] }.first(5)
  summary = lowest_coverage.map { |k, v| "#{k} #{v[:coverage_pct]}%" }.join(", ")
  puts "Field completeness (lowest): #{summary}"
end

puts "Complete required rows: #{report[:complete_required_rows]} (#{report[:complete_required_rows_pct]}%)"

if report[:program_required_completeness].any?
  top_program_gaps = report[:program_required_completeness].first(3).map do |program, stats|
    "#{program} #{stats[:missing_required_pct]}% missing"
  end
  puts "Program required gaps (top): #{top_program_gaps.join(", ")}"
end

if report[:duplicate_emails].any?
  puts "Duplicate emails: #{report[:duplicate_emails].length}"
else
  puts "Duplicate emails: none"
end

if report[:email_domain_distribution].any?
  top_domains = report[:email_domain_distribution].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top email domains: #{top_domains}"
else
  puts "Top email domains: none"
end

if report[:duplicate_applicant_ids].any?
  puts "Duplicate applicant IDs: #{report[:duplicate_applicant_ids].length}"
else
  puts "Duplicate applicant IDs: none"
end

puts "Blank status: #{report[:blank_status]}"
puts "Blank stage: #{report[:blank_stage]}"
puts "Blank program: #{report[:blank_program]}"
puts "Invalid emails: #{report[:invalid_email_count]}"
puts "Invalid scores: #{report[:invalid_score_count]}"
puts "Scores out of range: #{report[:score_out_of_range_count]}"
puts "Invalid submitted_at: #{report[:invalid_submitted_at_count]}"
puts "Future submissions: #{report[:future_submissions_count]}"
puts "Stale submissions (#{report[:stale_submission_window_days]}d): #{report[:stale_submissions_count_180d]}"
puts "Unknown statuses: #{report[:unknown_status_count]}"
puts "Unknown stages: #{report[:unknown_stage_count]}"

if report[:score_stats]
  stats = report[:score_stats]
  puts "Score stats: min #{stats[:min]}, avg #{stats[:avg]}, max #{stats[:max]}, p50 #{stats[:p50]}, p90 #{stats[:p90]}, p95 #{stats[:p95]}"
else
  puts "Score stats: none"
end

if report[:submission_window]
  puts "Submission window: #{report[:submission_window][:earliest]} -> #{report[:submission_window][:latest]}"
else
  puts "Submission window: none"
end

if report[:submission_age_days_stats]
  stats = report[:submission_age_days_stats]
  puts "Submission age (days): min #{stats[:min_days]}, avg #{stats[:avg_days]}, max #{stats[:max_days]}, p50 #{stats[:p50_days]}, p90 #{stats[:p90_days]}, p95 #{stats[:p95_days]}"
end

puts "Recent submissions (#{report[:recent_submission_window_days]}d): #{report[:recent_submissions]}"
if report[:submission_recency_buckets].any?
  bucket_summary = report[:submission_recency_buckets].map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Submission recency buckets: #{bucket_summary}"
end
if report[:program_distribution].any?
  top_programs = report[:program_distribution].first(5).map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top programs: #{top_programs}"
else
  puts "Top programs: none"
end

if report[:status_stage_distribution].any?
  top_pairs = report[:status_stage_distribution].flat_map do |status, stages|
    stages.map { |stage, count| ["#{status} -> #{stage}", count] }
  end.sort_by { |_, v| -v }.first(5)
  pair_summary = top_pairs.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top status-stage combos: #{pair_summary}"
else
  puts "Top status-stage combos: none"
end

if report[:program_status_distribution].any?
  top_program_pairs = report[:program_status_distribution].flat_map do |program, statuses|
    statuses.map { |status, count| ["#{program} -> #{status}", count] }
  end.sort_by { |_, v| -v }.first(5)
  program_summary = top_program_pairs.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top program-status combos: #{program_summary}"
else
  puts "Top program-status combos: none"
end

if report[:submission_weekday_distribution].any?
  top_days = report[:submission_weekday_distribution].sort_by { |_, v| -v }.first(3)
  day_summary = top_days.map { |k, v| "#{k}=#{v}" }.join(", ")
  puts "Top submission days: #{day_summary}"
end

if report[:submission_hour_distribution].any?
  top_hours = report[:submission_hour_distribution].sort_by { |_, v| -v }.first(3)
  hour_summary = top_hours.map { |k, v| "#{k}:00=#{v}" }.join(", ")
  puts "Top submission hours: #{hour_summary}"
end

puts "Issue rows: #{report[:issue_count]}"

if report[:issue_samples].any?
  puts "Sample issues:"
  report[:issue_samples].each do |issue|
    puts "- Row #{issue[:row]} (#{issue[:applicant_id] || "n/a"}): #{issue[:issues].join(", ")}"
  end
end

if options[:json_path]
  puts "JSON report: #{File.expand_path(options[:json_path])}"
end
